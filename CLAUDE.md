# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Berliner is a Go backend application for sharing hobbies. It's built with Gin web framework, MySQL database, and follows a three-layer architecture pattern.

## Prerequisites

- Go 1.23+
- PostgreSQL 12+
- Docker (for running tests)
- Wire (Google's dependency injection code generator) - installed via `go get github.com/google/wire/cmd/wire`

**Note:** Database migrations are managed in a separate repository (`berliner_database`)

## Environment Setup

The application requires configuration in the `configs/` directory:

1. `config.yaml` - Contains database and AWS configuration:
   - `db.user` - PostgreSQL username
   - `db.address` - PostgreSQL host address (e.g., `localhost:5432` or `localhost`)
   - `db.name` - Database name
   - `db.sslmode` - SSL mode (optional, defaults to `require`. Use `disable` for local development)
   - `aws.enabled` - Set to `true` for AWS Secrets Manager, `false` for local `.env` file
   - `aws.region` - AWS region for Secrets Manager (e.g., `eu-north-1`)
   - `aws.secrets.db_password` - AWS Secrets Manager secret name for database password
   - `aws.secrets.jwt_secret` - AWS Secrets Manager secret name for JWT secret

2. `.env` (only when `aws.enabled: false`) - Local secrets file:
   - `DB_PASSWORD` - PostgreSQL password
   - `JWT_SECRET` - Secret key for JWT token generation

### Local Development

For local development, set `aws.enabled: false` in `config.yaml` and create a `configs/.env` file:
```
DB_PASSWORD=your_local_db_password
JWT_SECRET=your_local_jwt_secret
```

### AWS Secrets Manager Setup (Production)

When `aws.enabled: true`, secrets are fetched from AWS Secrets Manager. You need to create two secrets:

1. **Database Password Secret** (e.g., `berliner/db_password`)
   - Store the PostgreSQL password as a plain text secret value

2. **JWT Secret** (e.g., `berliner/jwt_secret`)
   - Store the JWT signing key as a plain text secret value

**AWS Authentication**: The application uses the default AWS credential chain. Configure credentials via:
- Environment variables (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`)
- AWS credentials file (`~/.aws/credentials`)
- IAM role (when running on EC2/ECS/Lambda)

**Required IAM Permissions**:
```json
{
  "Effect": "Allow",
  "Action": "secretsmanager:GetSecretValue",
  "Resource": [
    "arn:aws:secretsmanager:REGION:ACCOUNT:secret:berliner/db_password-*",
    "arn:aws:secretsmanager:REGION:ACCOUNT:secret:berliner/jwt_secret-*"
  ]
}
```

The PostgreSQL DSN (Data Source Name) is constructed in `main.go:setupConfigs()` using secrets fetched from AWS Secrets Manager

## Common Commands

### Running the application
```bash
make               # Run the application (default target)
make run           # Explicitly run the application
go run .           # Alternative way to run
```

### Building
```bash
make build         # Builds executable as 'bin' in project root (automatically runs wire generation first)
make get           # Install dependencies (runs go get)
make wire          # Generate Wire dependency injection code (wire_gen.go)
```

### Wire Dependency Injection
The project uses [Wire](https://github.com/google/wire/blob/main/docs/guide.md) for compile-time dependency injection. Wire automatically generates code to wire up your application's dependencies.

**IMPORTANT**: Always run `make wire` after making changes that affect dependency injection. The build target automatically runs wire, but running it explicitly ensures `wire_gen.go` is up to date.

Key files:
- `wire.go` - Contains provider functions and injector declarations (with `//go:build wireinject` tag)
- `wire_gen.go` - Auto-generated by Wire, contains the actual dependency injection code (with `//go:build !wireinject` tag)

When to regenerate Wire code (`make wire`):
- After modifying `wire.go` (adding/removing providers)
- After changing constructor signatures in repository, services, or handler layers
- After adding new packages that need to be wired into the dependency graph
- When build fails with Wire-related errors

**Note**: The `pkg/secrets` package is NOT part of Wire dependency injection. Secrets are loaded in `main.go:setupConfigs()` before `InitializeApp()` is called, so they don't need Wire providers. If you add a new package that needs to be injected into the app (e.g., a new service layer), you must:
1. Add a provider function in `wire.go`
2. Add it to the `wire.Build()` call in `InitializeApp()`
3. Run `make wire` to regenerate `wire_gen.go`

### Database migrations
Database migrations are managed through a separate repository (`berliner_database`) located at `../berliner_database/`. The migration tool reads configuration from this project's `configs/config.yaml` and `configs/.env` files.

**Prerequisites:** The `berliner_database` repository must be cloned as a sibling directory to `berliner_backend`.

**From berliner_backend (delegates to database Makefile):**
```bash
make db_up         # Apply all migrations (creates tables)
make db_down       # Rollback all migrations (drops all tables)
make db_status     # Show current migration version and status
```

Alternative commands (legacy):
```bash
make database_up   # Same as db_up
make database_down # Same as db_down
```

**From berliner_database (recommended for advanced operations):**
```bash
cd ../berliner_database
make up            # Apply all migrations
make down          # Rollback all migrations
make status        # Show migration status (default)
make migrate VERSION=1    # Migrate to specific version
make force VERSION=1      # Force set version (use with caution)
make help          # Show all available commands
```

Migration files are located in the `berliner_database/migrations/` directory and use the golang-migrate format. See `../berliner_database/README.md` for detailed information on creating and managing migrations.

**Repository Structure:**
```
personal/
├── berliner_backend/    (this project)
│   ├── configs/         (configuration files used by both projects)
│   └── Makefile         (delegates db_* commands to berliner_database)
└── berliner_database/   (separate database repository)
    ├── migrations/      (SQL migration files)
    └── Makefile         (database-specific commands)
```

### Testing
```bash
make test_services # Run service layer tests (note: typo in Makefile, should be 'go test')
cd pkg/services && go test -v -cover  # Correct command to run tests
```

Tests use dockertest to spin up a MySQL container, so Docker must be running. Tests are located in `pkg/services/service_test.go`.

## Architecture

The codebase follows a clean three-layer architecture:

### Layer 1: Handler (pkg/handler/)
- HTTP request handling via Gin framework
- Route definition and middleware setup
- Authentication middleware using JWT tokens
- CORS configuration (currently allows localhost:5173)
- Files: `handler.go` (routing), `auth.go` (signup/login), `api.go` (API endpoints), `middlewares.go`

### Layer 2: Services (pkg/services/)
- Business logic layer
- Two main service interfaces: `Authorization` and `Api`
- `Authorization` handles user registration, password hashing (bcrypt), JWT token generation/parsing
- `Api` handles channels, posts, following/followers functionality
- Files: `services.go` (interfaces), `auth.go`, `api.go`

### Layer 3: Repository (pkg/repository/)
- Data access layer
- Database operations using sqlx
- Files: `repository.go` (interfaces), `database.go` (SQL queries)

### Secrets Management (pkg/secrets/)
- AWS Secrets Manager integration
- Fetches sensitive credentials at application startup
- Files: `secrets.go` (AWS Secrets Manager client)

### Database Management (separate repository: berliner_database)
- Standalone migration tool in separate repository at `../berliner_database/`
- Migration files in `berliner_database/migrations/`
- Uses golang-migrate for schema versioning
- Reads configuration from this project's `configs/` directory
- See `../berliner_database/README.md` for usage instructions

### Models (models/)
- Data structures representing database tables
- `models.go` contains: User, Channel, Post, UserPost, ChannelPost, Membership, Following, AuthorizationForm
- Custom `NullInt64` type with JSON marshaling support
- `interface.go` contains validation interfaces

### Database Schema

The application uses 7 main tables:
- `user` - User accounts with authentication info
- `channel` - Content channels led by users
- `membership` - Many-to-many relationship between users and channels with editor permissions
- `following` - User following relationships
- `user_post` - Posts created by individual users
- `channel_post` - Posts created by channels
- `request` - Channel membership requests (appears unused in current code)

Posts are split into `user_post` and `channel_post` tables with a shared `Post` base structure that includes `author_type` enum.

## Key Implementation Details

### Dependency Injection Flow
The application uses Wire for dependency injection. Wire generates code in `wire_gen.go` based on providers defined in `wire.go`:

**Configuration:**
- A `Config` struct holds the DSN (Data Source Name)
- Config is created in `main.go` from environment variables and config files

**Provider Functions (in wire.go):**
1. `ProvideRepository(config Config)` - Creates repository layer with DSN
2. `ProvideServices(repo *repository.Repository)` - Creates services layer with repository
3. `ProvideHandler(services *services.Services)` - Creates handler layer with services
4. `ProvideRouter(handler *handler.Handler)` - Initializes Gin router

**Injectors:**
- `InitializeApp(config Config)` - Wires up all dependencies and returns the router

**Startup Flow (in main.go):**
1. Load configuration from `config.yaml`
2. Fetch secrets (DB_PASSWORD, JWT_SECRET) from AWS Secrets Manager
3. Set environment variables for secrets (used by services layer)
4. Construct DSN and create Config struct
5. Initialize full app via `InitializeApp(config)` using Wire-generated code
6. Start Gin server

**Note:** Database migrations are no longer run automatically on startup. They must be run separately using the standalone migration tool in the `database/` directory.

### Authentication
- JWT tokens are used for authentication
- Tokens include username in claims
- `AuthMiddleware()` in handler extracts user from token and adds to Gin context
- Passwords are hashed with bcrypt before storage

### API Routes Structure
Public routes (no auth):
- POST `/signup` - User registration
- POST `/login` - User authentication

Protected routes (requires JWT token in Authorization header):
- GET `/` - Main page (returns current user info)
- GET/POST/PATCH/DELETE `/channels` - Channel CRUD operations
- POST/GET/DELETE `/post` - Post operations
- GET `/myPost` - Get posts from user's own channels
- POST/DELETE `/follow` - Follow/unfollow users or channels
- GET `/following` - Get list of followed users
- GET `/newPost` - Get recent posts from followed users/channels

### Transaction Handling
The repository layer implements a `Transaction` interface (see `models/interface.go`) for operations requiring atomicity, particularly channel creation which involves creating both the channel and initial membership.
